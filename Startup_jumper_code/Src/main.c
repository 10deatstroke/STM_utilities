/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#define __SOFT_FP__

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uint32_t calc_asm_crc32(uint8_t *data, uint32_t size){
	register uint32_t checksum	__asm("r3") = 0;
	__asm volatile(
			"					ldr		r4,	CRC_ADD			\n\t"
			"					movs	r5,		#0				\n\t"			//	r5 size counter
			"					subs	r6,		r5,		#1		\n\t"			//	r6 loaded with checksum
			"data_load:			ldrb	r9,		[r0,	r5]		\n\t"			//	r7 reading data from (address + r5)
			"					lsls	r9,		r9, 	#24		\n\t"
			"					eors	r6,		r9				\n\t"
			"					movs	r8,		#7				\n\t"			//	r8 rotation counter till 8
			"inner_loop:		cmp		r6,		#0				\n\t"
			"					bge		BITFAIL					\n\t"
			"					lsls	r6,		#1				\n\t"
			"					eors	r6,		r4				\n\t"
			"					b		inner_loop_decr			\n\t"
			"BITFAIL:			lsls	r6,		#1				\n\t"
			"inner_loop_decr:	subs	r8,		#1				\n\t"
			"					bpl		inner_loop				\n\t"
			"					add		r5, 	#1				\n\t"
			"					cmp		r5,		r1				\n\t"
			"					bne		data_load				\n\t"
			"					mov		r3,	r6					\n\t"
			"CRC_ADD:			.word	0x4C11DB7				\n\t"
			);
	return checksum;
}

void jump(uint32_t vect_table_address){

	__asm volatile(
			"					cpsie	i						\n\t"
/*
 * 			loading first vector table entry to r2 which is stack top
 */
			"					ldr 	r2,		[r0, 	#0]		\n\t"
/*
 * 			first vector table entry is msp so loading it back to msp register
 *			thus resetting MSP to base location
 *			NOTE : It is not a necessary step as every code's reset handler's first instruction
 *			is to load msp so doing it here is redundant
 */
			"					msr 	msp,	r2				\n\t"
/*
 * 			loading second vector table entry to r3 which is reset handler
 */
			"					ldr 	r3,		[r0,	#4]		\n\t"
/*
 * 			instruction used here is branch with exchange as normal branch instructions jumps to labels only and we need variable jump address
 * 			thus branch with exchange instructions are the only instructions that can load variable data from registers
 * 			NOTE: This instruction switches current running mode
 * 			arm mode to thumb mode if running in arm,
 * 			thumb mode to arm mode if running in thumb,
 * 			based on the last bit, change state if last bit of register is 0
 * 			for cortex-m series only thumb mode is supported thus if last bit is 0,
 * 			cortex will try to change state which is not supported thus leading to hardfault of "INVSTATE"
 * 			thus data in register will be (actual address + 1) for cortex-m series when bx is used
 */
			"					bx 		r3						\n\t"
			);

}

int main(void)
{
//	jump(0x08004000);
	uint8_t data[4] = {0x01, 0x02, 0x03, 0x04};
	calc_asm_crc32(data, 4);
//	calculate_crc32(data, 4);
    /* Loop forever */
	for(;;);
}
